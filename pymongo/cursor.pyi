from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union

from pymongo.collation import Collation
from pymongo.collection import Collection
from pymongo.message import _GetMore, _Query
from pymongo.pool import Pool, SocketInfo

_QUERY_OPTIONS: Dict[str, int] = ...
class CursorType(object):
    NON_TAILABLE: int = ...
    TAILABLE: int = ...
    TAILABLE_AWAIT: int = ...
    EXHAUST: int = ...

class _SocketManager:
    def __init__(self, sock: SocketInfo, pool: Pool) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...

class Cursor(object):
    def __init__(self, collection: Collection, filter: Mapping[str, Any] = ..., projection: Mapping[str, Any] = ..., skip: int = ..., limit: int = ..., no_cursor_timeout: bool = ..., cursor_type: int = ..., sort: Optional[Sequence[Tuple[str, Any]]] = ..., allow_partial_results: bool = ..., oplog_replay: bool = ..., modifiers: Optional[Mapping[str, Any]] = ..., batch_size: int = ..., manipulate: bool = ..., collation: Optional[Mapping[str, Any]] = ...) -> None: ...
    @property
    def collection(self) -> Collection: ...
    @property
    def retrieved(self) -> int: ...
    def __del__(self) -> None: ...
    def rewind(self) -> 'Cursor': ...
    def clone(self) -> 'Cursor': ...
    def _clone(self, deepcopy: bool = ...) -> 'Cursor': ...
    def _clone_base(self) -> 'Cursor': ...
    def __die(self, synchronous: bool = ...) -> None: ...
    def close(self) -> None: ...
    def __query_spec(self) -> Dict[str, Any]: ...
    def __check_okay_to_chain(self) -> None: ...
    def add_option(self, mask: int) -> 'Cursor': ...
    def remove_option(self, mask: int) -> 'Cursor': ...
    def limit(self, limit: int) -> 'Cursor': ...
    def batch_size(self, batch_size: int) -> 'Cursor': ...
    def skip(self, skip: int) -> 'Cursor': ...
    def max_time_ms(self, max_time_ms: int) -> 'Cursor': ...
    def max_await_time_ms(self, max_await_time_ms: int) -> 'Cursor': ...
    def __getitem__(self, index: Union[int, Sequence[int]]) -> Union['Cursor', Dict[str, Any]]: ...
    def max_scan(self, max_scan: int) -> 'Cursor': ...
    def max(self, spec: Sequence[Tuple[str, int]]) -> 'Cursor': ...
    def min(self, spec: Sequence[Tuple[str, int]]) -> 'Cursor': ...
    def sort(self, key_or_list: Union[str, Sequence[Tuple[str, Union[int, str]]]], direction: Optional[Union[int, str]] = ...) -> 'Cursor': ...
    def count(self, with_limit_and_skip: bool = ...) -> int: ...
    def distinct(self, key: str) -> List[Any]: ...
    def explain(self) -> Dict[str, Any]: ...
    def hint(self, index: Union[str, Tuple[str, Union[int, str]]]): ...
    def comment(self, comment: Union[str, Mapping[str, Any]]) -> 'Cursor': ...
    def where(self, code: str) -> 'Cursor': ...
    def collation(self, collation: Collation) -> 'Cursor': ...
    def __send_message(self, operation: Union[None, _GetMore, _Query]) -> None: ...
    def _refresh(self) -> int: ...
    @property
    def alive(self) -> bool: ...
    @property
    def cursor_id(self) -> int: ...
    @property
    def address(self) -> Tuple[str, int]: ...
    def __iter__(self) -> 'Cursor': ...
    def next(self) -> Dict[str, Any]: ...
    def __enter__(self) -> 'Cursor': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __copy__(self) -> 'Cursor': ...
    def __deepcopy__(self, memo: Any) -> 'Cursor': ...
    def _deepcopy(self, x: Mapping[str, Any], memo: Optional[Mapping[int, Any]] = ...) -> Union[List[Any], Dict[Any, Any]]: ...
