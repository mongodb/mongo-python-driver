from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union

from pymongo.client_session import ClientSession
from pymongo.collation import Collation
from pymongo.collection import Collection
from pymongo.message import _GetMore, _Query
from pymongo.pool import Pool, SocketInfo

_QUERY_OPTIONS: Dict[str, int] = ...
class CursorType(object):
    NON_TAILABLE: int = ...
    TAILABLE: int = ...
    TAILABLE_AWAIT: int = ...
    EXHAUST: int = ...

class _SocketManager:
    def __init__(self, sock: SocketInfo, pool: Pool) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...

class Cursor(object):
    def __init__(
        self,
        collection: Collection,
        filter: Mapping[str, Any] = ...,
        projection: Mapping[str, Any] = ...,
        skip: int = ...,
        limit: int = ...,
        no_cursor_timeout: bool = ...,
        cursor_type: int = ...,
        sort: Optional[Sequence[Tuple[str, Any]]] = ...,
        allow_partial_results: bool = ...,
        oplog_replay: bool = ...,
        modifiers: Optional[Mapping[str, Any]] = ...,
        batch_size: int = ...,
        manipulate: bool = ...,
        collation: Optional[Mapping[str, Any]] = ...,
        hint: Optional[Union[str, Tuple[str, Union[int, str]]]] = ...,
        max_scan: Optional[int] = ...,
        max_time_ms: Optional[int] = ...,
        max: Optional[Sequence[Tuple[str, int]]] = ...,
        min: Optional[Sequence[Tuple[str, int]]] = ...,
        return_key: bool = ...,
        show_record_id: bool = ...,
        snapshot: bool = ...,
        comment: Optional[Union[str, Mapping[str, Any]]] = ...,
        session: Optional[ClientSession] = ...) -> None: ...
    @property
    def collection(self) -> Collection: ...
    @property
    def retrieved(self) -> int: ...
    def __del__(self) -> None: ...
    def rewind(self) -> 'Cursor': ...
    def clone(self) -> 'Cursor': ...
    def close(self) -> None: ...
    def add_option(self, mask: int) -> 'Cursor': ...
    def remove_option(self, mask: int) -> 'Cursor': ...
    def limit(self, limit: int) -> 'Cursor': ...
    def batch_size(self, batch_size: int) -> 'Cursor': ...
    def skip(self, skip: int) -> 'Cursor': ...
    def max_time_ms(self, max_time_ms: int) -> 'Cursor': ...
    def max_await_time_ms(self, max_await_time_ms: int) -> 'Cursor': ...
    def __getitem__(self, index: Union[int, Sequence[int]]) -> Union['Cursor', Dict[str, Any]]: ...
    def max_scan(self, max_scan: int) -> 'Cursor': ...
    def max(self, spec: Sequence[Tuple[str, int]]) -> 'Cursor': ...
    def min(self, spec: Sequence[Tuple[str, int]]) -> 'Cursor': ...
    def sort(
        self,
        key_or_list: Union[str, Sequence[Tuple[str, Union[int, str]]]],
        direction: Optional[Union[int, str]] = ...) -> 'Cursor': ...
    def count(self, with_limit_and_skip: bool = ...) -> int: ...
    def distinct(self, key: str) -> List[Any]: ...
    def explain(self) -> Dict[str, Any]: ...
    def hint(self, index: Union[str, Tuple[str, Union[int, str]]]) -> Cursor: ...
    def comment(self, comment: Union[str, Mapping[str, Any]]) -> 'Cursor': ...
    def where(self, code: str) -> 'Cursor': ...
    def collation(self, collation: Collation) -> 'Cursor': ...
    @property
    def alive(self) -> bool: ...
    @property
    def cursor_id(self) -> int: ...
    @property
    def address(self) -> Tuple[str, int]: ...
    def __iter__(self) -> 'Cursor': ...
    def next(self) -> Dict[str, Any]: ...
    def __next__(self) -> Dict[str, Any]: ...
    def __enter__(self) -> 'Cursor': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __copy__(self) -> 'Cursor': ...
    def __deepcopy__(self, memo: Any) -> 'Cursor': ...

class RawBatchCursor(Cursor): ...
