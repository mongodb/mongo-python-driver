from typing import (Any, Callable, Dict, Iterable, Iterator, List, Mapping,
                    Optional, Sequence, Tuple, Union)

from bson.codec_options import CodecOptions
from pymongo.bulk import BulkOperationBuilder
from pymongo.collation import Collation
from pymongo.command_cursor import CommandCursor
from pymongo.common import BaseObject
from pymongo.cursor import Cursor
from pymongo.database import Database
from pymongo.operations import IndexModel, _WriteOp
from pymongo.pool import SocketInfo
from pymongo.read_concern import ReadConcern
from pymongo.read_preferences import _ServerMode
from pymongo.results import (BulkWriteResult, DeleteResult, InsertManyResult,
                             InsertOneResult, UpdateResult)
from pymongo.write_concern import WriteConcern


class ReturnDocument(object):
    BEFORE: bool = ...
    AFTER: bool = ...
class Collection(BaseObject):
    def __init__(self, database: Database, name: str, create: Optional[bool] = ..., codec_options: Optional[CodecOptions] = ..., read_preference: Optional[_ServerMode] = ..., write_concern: Optional[WriteConcern] = ..., read_concern: Optional[ReadConcern] = ..., **kwargs: Any) -> None: ...
    def _socket_for_reads(self) -> Iterator[Tuple[SocketInfo, bool]]: ...
    def _socket_for_primary_reads(self) -> Iterator[Tuple[SocketInfo, bool]]: ...
    def _socket_for_writes(self) -> Iterator[SocketInfo]: ...
    def _command(self, sock_info: SocketInfo, command: Mapping[str, Any], slave_ok: bool = ..., read_preference: Optional[_ServerMode] = ..., codec_options: Optional[CodecOptions] = ..., check: bool = ..., allowable_errors: Optional[Sequence[str]] = ..., read_concern: Optional[ReadConcern] = ..., write_concern: Optional[WriteConcern] = ..., parse_write_concern_error: bool = ..., collation: Optional[Collation] = ...) -> Dict[str, Any]: ...
    def __create(self, options: Mapping[str, Any], collation: Collation) -> None: ...
    def __getattr__(self, name: str) -> 'Collection': ...
    def __getitem__(self, name: str) -> 'Collection': ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    @property
    def full_name(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def database(self) -> Database: ...
    def with_options(self, codec_options: Optional[CodecOptions] = ..., read_preference: Optional[_ServerMode] = ..., write_concern: Optional[WriteConcern] = ..., read_concern: Optional[ReadConcern] = ...) -> 'Collection': ...
    def initialize_unordered_bulk_op(self, bypass_document_validation: bool = ...) -> BulkOperationBuilder: ...
    def initialize_ordered_bulk_op(self, bypass_document_validation: bool = ...) -> BulkOperationBuilder: ...
    def bulk_write(self, requests: Sequence[_WriteOp], ordered: bool = ..., bypass_document_validation: bool = ...) -> BulkWriteResult: ...
    def _legacy_write(self, sock_info: SocketInfo, name: str, cmd: Mapping[str, Any], acknowledged: bool, op_id: int, bypass_doc_val: bool, func: Callable[[Any], Any], *args: Any) -> Dict[str, Any]: ...
    def _insert_one(self, sock_info: SocketInfo, doc: Mapping[str, Any], ordered: bool, check_keys: bool, manipulate: bool, write_concern: WriteConcern, op_id: int, bypass_doc_val: bool) -> Any: ...
    def _insert(self, sock_info: SocketInfo, docs: Union[Mapping[str, Any], Sequence[Mapping[str, Any]]], ordered: bool = ..., check_keys: bool = ..., manipulate: bool = ..., write_concern: Optional[WriteConcern] = ..., op_id: Optional[int] = ..., bypass_doc_val: bool = ...) -> Any: ...
    def insert_one(self, document: Any, bypass_document_validation: bool = ...) -> InsertOneResult: ...
    def insert_many(self, documents: Iterable[Any], ordered: bool = ..., bypass_document_validation: bool = ...) -> InsertManyResult: ...
    def _update(self, sock_info: SocketInfo, criteria: Mapping[str, Any], document: Mapping[str, Any], upsert: bool = ..., check_keys: bool = ..., multi: bool = ..., manipulate: bool = ..., write_concern: Optional[WriteConcern] = ..., op_id: Optional[int] = ..., ordered: bool = ..., bypass_doc_val: bool = ..., collation: Optional[Collation] = ...) -> Dict[str, Any]: ...
    def replace_one(self, filter: Mapping[str, Any], replacement: Mapping[str, Any], upsert: bool = ..., bypass_document_validation: bool = ..., collation: Optional[Collation] = ...) -> UpdateResult: ...
    def update_one(self, filter: Mapping[str, Any], update: Mapping[str, Any], upsert: bool = ..., bypass_document_validation: bool = ..., collation: Optional[Collation] = ...) -> UpdateResult: ...
    def update_many(self, filter: Mapping[str, Any], update: Mapping[str, Any], upsert: bool = ..., bypass_document_validation: bool = ..., collation: Optional[Collation] = ...) -> UpdateResult: ...
    def drop(self) -> None: ...
    def _delete(self, sock_info: SocketInfo, criteria: Mapping[str, Any], multi: bool, write_concern: Optional[WriteConcern] = ..., op_id: Optional[int] = ..., ordered: bool = ..., collation: Optional[Collation] = ...) -> Dict[str, Any]: ...
    def delete_one(self, filter: Mapping[str, Any], collation: Optional[Collation] = ...) -> DeleteResult: ...
    def delete_many(self, filter: Mapping[str, Any], collation: Optional[Collation] = ...) -> DeleteResult: ...
    def find_one(self, filter: Optional[Mapping[str, Any]] = ..., *args: Any, **kwargs: Any) -> Optional[Dict[str, Any]]: ...
    def find(self, *args: Any, **kwargs: Any) -> Cursor: ...
    def parallel_scan(self, num_cursors: int, **kwargs: Any) -> List[CommandCursor]: ...
    def _count(self, cmd: Mapping[str, Any], collation: Optional[Collation] = ...) -> int: ...
    def count(self, filter: Optional[Mapping[str, Any]] = ..., **kwargs: Any) -> int: ...
    def create_indexes(self, indexes: Sequence[IndexModel], **kwargs: Any) -> List[str]: ...
    def __create_index(self, keys: Sequence[Tuple[str, Union[int, str]]], index_options: Mapping[str, Any]) -> None: ...
    def create_index(self, keys: Union[str, Sequence[Tuple[str, Union[int, str]]]], **kwargs: Any) -> str: ...
    def ensure_index(self, key_or_list: Union[str, Sequence[Tuple[str, Union[int, str]]]], cache_for: int = ..., **kwargs: Any) -> Optional[str]: ...
    def drop_indexes(self) -> None: ...
    def drop_index(self, index_or_name: Union[str, Sequence[Tuple[Any, Any]]]) -> None: ...
    def reindex(self) -> Dict[str, Any]: ...
    def list_indexes(self) -> CommandCursor: ...
    def index_information(self) -> Dict[str, Any]: ...
    def options(self) -> Dict[str, Any]: ...
    def _aggregate(self, pipeline: Sequence[Mapping[str, Any]], **kwargs: Any) -> CommandCursor: ...
    def aggregate(self, pipeline: Sequence[Mapping[str, Any]], **kwargs: Any) -> CommandCursor: ...
    def group(self, key: Mapping[str, Any], condition: Mapping[str, Any], initial: Mapping[str, int], reduce: str, finalize: str = ..., **kwargs: Any) -> List[Dict[str, Any]]: ...
    def rename(self, new_name: str, **kwargs: Any) -> None: ...
    def distinct(self, key: str, filter: Optional[Mapping[str, Any]] = ..., **kwargs: Any) -> List[Any]: ...
    def map_reduce(self, map: str, reduce: str, out: Union[str, Mapping[str, Any]], full_response: bool = ..., **kwargs: Any) -> Union[Dict[str, Any], Database, 'Collection']: ...
    def inline_map_reduce(self, map: str, reduce: str, full_response: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def __find_and_modify(self, filter: Mapping[str, Any], projection: Union[Sequence[str], Mapping[str, bool]], sort: Sequence[Tuple[str, Union[int, str]]], upsert: Optional[bool] = ..., return_document: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def find_one_and_delete(self, filter: Mapping[str, Any], projection: Optional[Union[Sequence[str], Mapping[str, bool]]] = ..., sort: Optional[Sequence[Tuple[str, Union[int, str]]]] = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def find_one_and_replace(self, filter: Mapping[str, Any], replacement: Mapping[str, Any], projection: Optional[Union[Sequence[str], Mapping[str, bool]]] = ..., sort: Optional[Sequence[Tuple[str, Union[int, str]]]] = ..., upsert: bool = ..., return_document: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def find_one_and_update(self, filter: Mapping[str, Any], update: Mapping[str, Any], projection: Optional[Union[Sequence[str], Mapping[str, bool]]] = ..., sort: Optional[Sequence[Tuple[str, Union[int, str]]]] = ..., upsert: bool = ..., return_document: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def save(self, to_save: Mapping[str, Any], manipulate: bool = ..., check_keys: bool = ..., **kwargs: Any) -> Any: ...
    def insert(self, doc_or_docs: Mapping[str, Any], manipulate: bool = ..., check_keys: bool = ..., continue_on_error: bool = ..., **kwargs: Any) -> Any: ...
    def update(self, spec: Mapping[str, Any], document: Mapping[str, Any], upsert: bool = ..., manipulate: bool = ..., multi: bool = ..., check_keys: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def remove(self, spec_or_id: Optional[Mapping[str, Any]] = ..., multi: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def find_and_modify(self, query: Mapping[str, Any] = {}, update: Mapping[str, Any] = ..., upsert: bool = ..., sort: Optional[Sequence[Tuple[str, Union[int, str]]]] = ..., full_response: bool = ..., manipulate: bool = ..., **kwargs: Any) -> Dict[str, Any]: ...
    def __iter__(self) -> 'Collection': ...
    def __next__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> None: ...
