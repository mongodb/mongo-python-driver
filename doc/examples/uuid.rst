.. _Handling UUID Data:

Handling UUID Data
==================

PyMongo ships with built-in support for dealing with UUID types.
It is trivially simple to store native :class:`uuid.UUID` objects
to MongoDB and retrieve them as native :class:`uuid.UUID`s::

  from pymongo import MongoClient
  from bson.binary import UuidRepresentation
  from uuid import uuid4

  # use the 'standard' representation for cross-language compatibility.
  client = MongoClient(uuid_representation=UuidRepresentation.STANDARD)
  collection = client.get_database('uuid_db').get_collection('uuid_coll')

  # remove all documents from collection
  collection.delete_many({})

  # create a native uuid object
  uuid_obj = uuid4()

  # save the native uuid object to MongoDB
  collection.insert_one({'uuid': uuid_obj})

  # retrieve the stored uuid object from MongoDB
  document = collection.find_one({})

  # check that the retrieved document matches the inserted document
  assert document['uuid'] == uuid_obj

Native :class:`uuid.UUID`s can also be used as part of MongoDB queries::

  document = collection.find({'uuid': uuid_obj})
  assert document['uuid'] == uuid_obj

The above examples illustrate the simplest of use-cases - one where the
UUID is generated by, and used in the same application. However,
the situation can be significantly more complex when dealing with a MongoDB
deployment that contains UUIDs created by other drivers as the Java and CSharp
drivers have historically encoded UUIDs using a byte-order that is different
from the one used by PyMongo. Applications that require interoperability across
these drivers must specify the appropriate
:class:`~bson.binary.UuidRepresentation`.

In the following sections, we describe how drivers have historically differed
in their encoding of UUIDs, and how applications can use the
:class:`~bson.binary.UuidRepresentation` configuration option to maintain
cross-language compatibility.

.. attention:: Applications that do not share a MongoDB deployment with
   any other application and that have never stored UUIDs in MongoDB
   should use the ``standard`` UUID representation for cross-language
   compatibility. See :ref:`configuring-uuid-representation` for details
   on how to configure the :class:`~bson.binary.UuidRepresentation`.

.. _example-legacy-uuid:

Legacy Handling of UUID Data
----------------------------

Historically, MongoDB Drivers have used different byte-ordering
while serializing UUID types to :class:`~bson.binary.Binary`.
Consider, for instance, a UUID with the following canonical textual
representation::

  00112233-4455-6677-8899-aabbccddeeff

This UUID would historically be serialized by the Python driver as::

  00112233-4455-6677-8899-aabbccddeeff

The same UUID would historically be serialized by the C# driver as::

  33221100-5544-7766-8899-aabbccddeeff

Finally, the same UUID would historically be serialized by the Java driver as::

  77665544-3322-1100-ffee-ddccbbaa9988

.. note:: For in-depth information about the the byte-order historically
   used by different drivers, see the `Handling of Native UUID Types
   Specification
   <https://github.com/mongodb/specifications/blob/master/source/uuid.rst>`_.

This difference in the byte-order of UUIDs encoded by different drivers
resulted in highly unintuitive behavior in deployments where more than
one of these drivers was in use. As example, consider the following situation:

* Application ``M`` written in C# generates a UUID and uses it as the ``_id``
  of a document that it proceeds to insert into the ``uuid_test`` collection of
  the ``example_db`` database. Let's assume that the canonical textual
  representation of the generated UUID is::

    00112233-4455-6677-8899-aabbccddeeff

* Application ``N`` written in Python attempts to ``find`` the document
  written by application ``M`` in the following manner::

    from uuid import UUID
    collection = client.example_db.uuid_test
    results = collection.find({'_id': UUID('00112233-4455-6677-8899-aabbccddeeff')})

  In this instance, the ``results`` cursor will never contain the document that
  was inserted by application ``M`` in the previous step. This is because of
  the different byte-order used by the C# driver for representing UUIDs as
  BSON Binary. The following query, on the other hand, will successfully find
  this document::

    results = collection.find({'_id': UUID('33221100-5544-7766-8899-aabbccddeeff')})

As this example demonstrates, differing byte-order can hamper
interoperability between applications that use different drivers. To workaround
this problem, users can configure their ``MongoClient`` with the appropriate
:class:`~bson.binary.UuidRepresentation`.

.. _configuring-uuid-representation:

Configuring a UUID Representation
---------------------------------

Setting a :class:`~bson.binary.UuidRepresentation` configures
PyMongo's behavior while encoding/decoding native UUID types to/from BSON.
Applications can set the UUID representation in one of the following ways:

#. Using the ``uuidRepresentation`` URI option::

  client = MongoClient("mongodb://a:27107/?uuidRepresentation=javaLegacy")

  Valid values are ``pythonLegacy``, ``javaLegacy``, ``csharpLegacy``,
  ``standard`` and ``unspecified``.

#. Using the ``uuid_representation`` kwarg option::

  from bson.binary import UuidRepresentation
  client = MongoClient(uuid_representation=UuidRepresentation.PYTHON_LEGACY)

#. By supplying a suitable :class:`~bson.codec_options.CodecOptions` instance::

  from bson.codec_options import CodecOptions
  csharp_opts = CodecOptions(uuid_representation=UuidRepresentation.CSHARP_LEGACY)
  csharp_database = client.get_database('csharp_db', codec_options=csharp_opts)
  csharp_collection = client.testdb.get_collection('csharp_coll', codec_options=csharp_opts)


We now detail the behavior and use-case for each support UUID representation.

The ``PYTHON_LEGACY`` UUID Representation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. attention:: This uuid representation should be used when reading UUIDs
   written to MongoDB by existing applications that use the Python driver
   and don't explicitly set a UUID representation.

.. attention:: As of PyMongo 3.11.0,
   :data:`~bson.binary.UuidRepresentation.PYTHON_LEGACY`
   is the default uuid representation used by PyMongo.

The :data:`~bson.binary.UuidRepresentation.PYTHON_LEGACY` representation
corresponds to the legacy representation of UUIDs used by PyMongo. This
representation conforms with
`RFC 4122 Section 4.1.2 <https://tools.ietf.org/html/rfc4122#section-4.1.2>`_.

This is illustrated with the following example::

  from bson.codec_options import CodecOptions, DEFAULT_CODEC_OPTIONS
  from bson.binary import UuidRepresentation

  # No configured UUID representation (legacy
  collection = client.python_legacy.get_collection('test', codec_options=DEFAULT_CODEC_OPTIONS)

  # Using UuidRepresentation.PYTHON_LEGACY
  pylegacy_opts = CodecOptions(uuid_representation=UuidRepresentation.PYTHON_LEGACY)
  pylegacy_collection = client.python_legacy..get_collection('test', codec_options=pylegacy_opts)

  # UUIDs written by PyMongo with no UuidRepresentation configured can be queried using PYTHON_LEGACY
  uuid_1 = uuid4()
  collection.insert_one({'uuid': uuid_1})
  document = pylegacy_collection.find_one({'uuid': uuid_1})

  # UUIDs written using PYTHON_LEGACY can be read by PyMongo with no UuidRepresentation configured
  uuid_2 = uuid4()
  pylegacy_collection.insert_one({'uuid': uuid_2})
  document = collection.find_one({'uuid': uuid_2})

``PYTHON_LEGACY`` encodes native :class:`uuid.UUID`s to :class:`~bson.binary.Binary`
subtype 3 objects, preserving the same byte-order as :class:`uuid.UUID.bytes`::

  from bson.binary import Binary

  document = collection.find_one({'uuid': Binary(uuid_2.bytes, subtype=3)})
  assert document['uuid'] == uuid_2

The ``JAVA_LEGACY`` UUID Representation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. attention:: This uuid representation should be used when reading UUIDs
   written to MongoDB by the Java driver without an explicitly configured UUID
   representation.

The :data:`~bson.binary.UuidRepresentation.JAVA_LEGACY` representation
corresponds to the legacy representation of UUIDs used by the MongoDB Java
Driver.

.. note:: The ``JAVA_LEGACY`` representation reverses the order of bytes 0-7,
   and bytes 8-15.

As an example, consider the same UUID described in :ref:`example-legacy-uuid`.
Let us assume that an application used the Java driver without an explicitly
specified UUID representation to insert the example UUID
``00112233-4455-6677-8899-aabbccddeeff``into MongoDB. If we try to read this
value using PyMongo with no UUID representation specified, we end up with an
entirely different UUID::

  UUID('77665544-3322-1100-ffee-ddccbbaa9988')

However, if we explicitly set the representation to
:data:`~bson.binary.UuidRepresentation.JAVA_LEGACY`, we get the correct result::

  UUID('00112233-4455-6677-8899-aabbccddeeff')

PyMongo uses the specified UUID representation to reorder the BSON bytes and
load them correctly. ``JAVA_LEGACY`` encodes native :class:`uuid.UUID`s to
:class:`~bson.binary.Binary` subtype 3 objects, while performing the same
byte-reordering as the legacy Java driver's UUID to BSON encoder.

The ``CSHARP_LEGACY`` UUID Representation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. attention:: This uuid representation should be used when reading UUIDs
   written to MongoDB by the C# driver without an explicitly configured UUID
   representation.

The :data:`~bson.binary.UuidRepresentation.CSHARP_LEGACY` representation
corresponds to the legacy representation of UUIDs used by the MongoDB Java
Driver.

.. note:: The ``CSHARP_LEGACY`` representation reverses the order of bytes 0-3,
   bytes 4-5, and bytes 6-7.

As an example, consider the same UUID described in :ref:`example-legacy-uuid`.
Let us assume that an application used the C# driver without an explicitly
specified UUID representation to insert the example UUID
``00112233-4455-6677-8899-aabbccddeeff``into MongoDB. If we try to read this
value using PyMongo with no UUID representation specified, we end up with an
entirely different UUID::

  UUID('33221100-5544-7766-8899-aabbccddeeff')

However, if we explicitly set the representation to
:data:`~bson.binary.UuidRepresentation.CSHARP_LEGACY`, we get the correct result::

  UUID('00112233-4455-6677-8899-aabbccddeeff')

PyMongo uses the specified UUID representation to reorder the BSON bytes and
load them correctly. ``CSHARP_LEGACY`` encodes native :class:`uuid.UUID`s to
:class:`~bson.binary.Binary` subtype 3 objects, while performing the same
byte-reordering as the legacy C# driver's UUID to BSON encoder.

The ``STANDARD`` UUID Representation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. attention:: This uuid representation should be used by new applications
   that have never stored UUIDs in MongoDB.

The :data:`~bson.binary.UuidRepresentation.STANDARD` representation
enables cross-language compatibility by ensuring the same byte-ordering
when encoding UUIDs from all drivers. UUIDs written by a driver with this
representation configured can be read by every other driver correctly provided
it is configured with the ``STANDARD`` representation.

``STANDARD`` encodes native :class:`uuid.UUID`s to
:class:`~bson.binary.Binary` subtype 4 objects.


The ``UNSPECIFIED`` UUID Representation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. attention:: Starting in PyMongo 4.0,
   :data:`~bson.binary.UuidRepresentation.UNSPECIFIED` will be the default
   UUID representation used by PyMongo.

The :data:`~bson.binary.UuidRepresentation.UNSPECIFIED` representation
prevents the incorrect interpretation of UUID bytes by stopping short of
automatically converting UUID fields in BSON to native UUID types. Loading
a UUID When using this representation returns a :data:`~bson.binary.Binary`
object instead. Users can explicitly convert the :data:`~bson.binary.Binary`
objects into native UUIDs in the appropriate representation by using the
:meth:`~bson.binary.Binary.as_uuid` method.
